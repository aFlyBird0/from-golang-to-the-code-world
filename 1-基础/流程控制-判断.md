# 流程控制-判断

我们来回顾一下现在已经拥有了哪些能力？

* 定义不同类型的变量，做各种计算
* 获取用户输入，并将结果输出出来
* 把复杂的可以被重用的代码片段封装成函数

我们已经拥有了以上的能力，再加上已经有了各种各样的现成的好用的「函数」。大部分时候写代码，只不过是各种函数的组合。

比如，我们想写个输入小明的生日和祝福的话语，程序将会在小明生日的时候给他发送短信。我们大概只需要找到一个获取当前日期的函数，再来个给指定人发送信息的「函数」，最后再让程序一直跑下去不退出就好了。加一些简单代码的串联，就能写出这样的程序。

但，是不是还差了点什么？

## If-else if-else

想卖关子也没法卖啊哈哈哈，题目已经出卖了——「流程控制-判断」。

下面是一个「一元二次方程求解」的例子

```go
import "math"

// Solve 求解一个一元二次方程，
// 需将方程组化为 ax^2+bx+c=0 的形式
func Solve(a, b, c float64) (x1, x2 float64) {	// float64 是小数类型的一种
  t := b*b - 4*a*c
  // math.Sqrt 是开根号函数
	return (-b + math.Sqrt(t)) / (2 * a), (-b - math.Sqrt(t)) / (2 * a)
}
```

大家对着注释看，这段代码肯定能看懂。

但是它少了一样东西，没有对 `b*b - 4*a*c` 是否大于等于 0 的判断！

为什么没有？因为前面根本没教！现在马上教给你！

我直接贴代码不说话：

```go
flag := 1
if flag > 1 {
  fmt.Println("哦豁a大于1！")
}
```

其中 `if` 是表示判断的关键词，`if` 这个单词的的中文意思就是 「如果」。

还可以再加一点东西，我继续不说话：

```go
password := "芝麻开门"
if password == "芝麻开门" {	// 编程里判断是否相等一般不用 "="，而用"=="。因为"="是赋值
  // 这里其实可以写任何行代码，只不过为了方便理解我都只是用了一个简单的输出
  fmt.Println("密码正确门开啦！")
} else {
  fmt.Println("密码错误！")
}
```

这里主要就是加了个 `else` 就是「否则」的意思。`if` 后面的是条件，条件成立就执行 `if` 旁边的大括号包裹的内容，不成立就执行 `else` 里的内容。

我再贴代码不说话！

```go
score := 85
var rank string
if score >= 90 { // 大于等于
  rank = "优秀"
} else if score < 90 && score >= 80 {
  rank = "良好"
} else if score < 80 && score >= 60 {
  rank = "及格"
} else {
  rank = "不及格"
}
fmt.Println("小明的成绩评级是：", rank)
```

上面的代码主要有两个新知识点：

* `&&` 代表逻辑与，可以理解成「且」，`score < 90 && score >= 80` 就等价于 `80 <= score < 90`。不过大部分程序不能这么写。「且」的意思就是，所有条件都满足才能满足。比如 `score>80 && age<20 && name=="小明"`，筛选出同时满足这三个条件的人。
* `else if`。我很难解释，但是你看代码应该能猜出来啥意思。

## 布尔值（bool）

大家应该能很轻松地看出来，`if` 和 `else if` 后面的东西是逻辑判断，或者说这个式子的结果应该是「对」或「错」，「满足」或「不满足」。或者更专业些说，就是「真」或「假」，`true` 或 `false`。

这种值叫做「布尔值」，编程里面有专门的一种数据类型来存储这种值，就叫「布尔型」，在 Go 里面类型的关键字是 `bool`。这个类型的值取值只有两种，零值是 `false`。比如：

```go
var thisBookIsCool bool
thisBookIsCool = true
if thisBookIsCool {
  // ...
}
```

这样就定义了一个 `thisBookIsCool` 的布尔值，并赋为 `true`。同时因为 `if` 后需要跟一个逻辑判断，或者说逻辑表达式，或者说一个式子最后的结果要是 `true` 或 `false`，而布尔值本身就是 `true` 或 `false`，所以可以直接跟在 `if` 后面。

## Switch

其实只用 `if`, `else if` 和 `else` 三件套就能处理所有的「判断」逻辑，但是许多语言，比如 Go，还支持一种比较优雅的判断的语法，适合判断条件很多的时候。

我直接给例子：

```go
name := "小明"
switch name {
	case "小红":
		fmt.Println("欢迎小红，这是位女同学")
  	// 可以写很多行
    // 不是只能写一行
	case "小明":
		fmt.Println("欢迎小明，这是位男同学")
	default:
		fmt.Println("欢迎!!!")
}
```

看代码可以推测出， `switch` 的中文意思是「开关」，我们就把它理解成开关。其中决定开关的是 `swtich` 后面的变量，这次是 `name`。如果值等于 "小红"，就.....；如果值等于"小明"，就.....；如果从上至下一个个比对都没中，就执行 `default` 里的内容。

再来个例子：

```go
score := 85	// 实际运行过程中这个 score 不一定是定死的，比如可以是用户输入的
var rank string
switch {
case score >= 90:
  rank = "优秀"
case score < 90 && score >= 80:
  rank = "良好"
case score < 80 && score >= 60:
  rank = "及格"
default:
  rank = "不及格"
}
fmt.Println("小明的成绩评级是：", rank)
```

`switch` 后面也可以不带变量，这样的话每个 `case` 后面就是一个逻辑表达式，如果结果为 `true` 就执行对应的 `case` 的内容。

Go 的 `switch` 还有很多玩法，就不一一展开。所有的判断本质上都是一样的：一个关键字+一个逻辑表达式，如果逻辑表达式最后算出来的结果是 `true`，就执行这个关键字管辖的对应块内的所有代码。
