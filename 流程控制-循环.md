# 流程控制-循环

有了判断就够了吗？当然不够。

编程的一大魅力就是减少重复性工作。

来个例子，前面的求根公式的例子的伪代码如下：

```text
输入 a, b, c
判断 b*b -4*a*c 是否大于等于0
若>=0: 调用求根公式，输出结果
否则：告诉用户此方程无实数解
```

## for 循环

用户想多次求解方程怎么办？

求解几次就把输入、求解函数调用、输出复制几次？

当然有更简单的办法，这就是循环，例如，想无限输出 `Hello World`，就可以这样写：

```go
for {
  fmt.Println("Hellow World")
}
```

同理，想无限求解方程，就这么写：

```go
for {
	// 输入 a, b, c
	// 判断 b*b -4*a*c 是否大于等于0
	// 若>=0: 调用求根公式，输出结果
	// 否则：告诉用户此方程无实数解
}
```

这么写其实是有问题的，尤其是第一种，这个循环是无限的循环，会疯狂执行下去，比如第一个程序可能一秒能输出几万个甚至更多的 `"Hello World"`，直到程序报错。

（第二个这么写倒是问题不大，因为输入的时候程序会停住等用户输入，所以第二个程序可以不断地求解方程，直到用户主动把程序关了）

## 控制循环次数

但我们能不能在程序内优雅地控制重复执行的次数？

怎么控制循环的次数呢？

其实我们可以换个角度想，如果我们有一个可以退出循环的命令，然后自己记录循环的次数，如果次数达到了就主动退出，代码如下：

```go
var countWant, countCurrent = 5, 0 // 假设我们想重复某个代码段 5 次

for {
  if countWant == countCurrent {
    break		// 如果当前循环的次数达到了预期，就用 break 这个命令退出循环
  }
  
  // 这里可以写
  // 你想
  // 循环执行的
  // 代码
  
  countCurrent = countCurrent + 1  // 更新当前循环的次数。这里也可以写成 countCurrent += 1，效果一样
}

fmt.Println("循环退出啦，继续执行 for 循环后面的代码")
// 后面的代码
```

其中最关键的就是 `break`，可以退出本层的循环，然后继续执行下面的代码。退出本层的循环指的是 `for` 里面还可以继续嵌套 `for`，`break` 只能退出它所在的那层循环。

```go
for {
  if 1==2 {
    break // 第一个 break
  }
  
  for {
    if 1==1 {
    	break // 第二个 break
  	}
  }
  fmt.Println("如果第二个 break 生效，代码会到这里继续执行")
}
fmt.Println("如果第一个 break 生效，代码会到这里继续执行")
```

其实更多时候会用 `range` 循环，但这个要配合后面的内容讲，先不讲。